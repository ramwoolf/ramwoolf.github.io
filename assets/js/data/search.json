[ { "title": "Как пользоваться Move semantic на примерах", "url": "/posts/move_semantic/", "categories": "coding, cpp", "tags": "", "date": "2022-08-16 23:30:00 +0200", "snippet": "В 2022 году всё ещё существует много компаний, для которых C++11 считается новым стандартом языка. С людьми лучше, множество конференций, статей, книжек, гайдов на ютубе танцев в тиктоке неплохо объяснили идеи и рапространили знания. Для новоприбывших же, возможно, дерево типов ссылок в C++, разные приколы и эффекты могут повергнуть в уныние. Потому, здесь я покажу без особых теоретических запилов как в 80% случаев надо пользоваться семантикой перемещения в версиях языка C++11 и новее. Если вы душный дед из твитора и испытываете желание самоудовлетвориться самоутвердиться, что теория лёгкая, и вы её за две минуты освоили в третьем классе на батином инженерном калькуляторе, то вы ошиблись дверью, хабрахабр дальше по коридору. Остальным велкам.Если же вы видите, что я где-то косякнул или что-то забыл упомянуть, пишите в телегу мне.Типы конструкторов и подготовкаЗдесь нам понадобятся два типа ссылок: обычная ссылка lvalue, которая может стоять слева (и справа) от присваивания (а значит имеет имя), и ссылка rvalue, которая может находиться только справа. Значениями типа rvalue являются результаты вызова функций, литералы.Начнём, пожалуй с того, что напишем пару килограммов бойлерплейта (нудного, объемного, жизненно необходимого, но весьма скучного кода). Будем использовать для экспериментов вот такой класс:class ClassName{public: ClassName() { std::cout &amp;lt;&amp;lt; &quot;Default ctor\\n&quot;; } ~ClassName() { std::cout &amp;lt;&amp;lt; &quot;Default dtor\\n&quot;; } ClassName(int const max_letter_number) : v(max_letter_number, &quot;aaa&quot;), s(&quot;Vector of triplets&quot;) { std::cout &amp;lt;&amp;lt; &quot;User defined ctor\\n&quot;; } ClassName(ClassName const&amp;amp;other) : v(other.v), s(other.s) { std::cout &amp;lt;&amp;lt;&quot;Copy ctor\\n&quot;; std::this_thread::sleep_for(std::chrono::seconds(5)); std::cout &amp;lt;&amp;lt;&quot;Copy ctor done\\n&quot;; } ClassName&amp;amp; operator=(ClassName const&amp;amp;other) { std::cout &amp;lt;&amp;lt; &quot;Copy assignment\\n&quot;; std::this_thread::sleep_for(std::chrono::seconds(5)); v = other.v; s = other.s; std::cout &amp;lt;&amp;lt; &quot;Copy assignment done\\n&quot;; return *this; } ClassName(ClassName &amp;amp;&amp;amp;other) : v(std::move(other.v)), s(std::move(other.s)) { std::cout &amp;lt;&amp;lt; &quot;Move ctor\\n&quot;; } ClassName&amp;amp; operator=(ClassName &amp;amp;&amp;amp;other) { std::cout &amp;lt;&amp;lt; &quot;Move assignment\\n&quot;; v = std::move(other.v); s = std::move(other.s); return *this; } std::size_t get_size() const { return v.size(); } void add_two() { v.push_back(&quot;ddd&quot;); v.push_back(&quot;fff&quot;); return; }private: std::vector&amp;lt;std::string&amp;gt; v; std::string s;};Что произошло? Не впадая в мерзкое упрощение с целыми числами, мы завели класс со строчкой и вектором строчек внутри. Для наглядности. Явно реализовали конструктор по умолчанию (без аргументов), пользовательский конструктор (с аргументами) и деструктор. Явно написали копирующие и перемещающие операции. Опять же, чтобы не вспоминать сейчас правило трёх пяти, и что там когда компилятор нам генерирует. Про это потом.Перемещающие операции отличаются синтаксически лишь двойным амперсандом (так обозначается rvalue ссыль) в списке параметров и отсутствием const. И вызовами std::move(), которая во время компиляции приводит тип аргумента как раз к нужной нам rvalue. Для встроенных типов в любом случае произойдёт копирование, для них недорогостоящее. Для обьектов, которые не содержат перемещающего конструктора, попытка перемещение так же будет заменена копированием. Так же есть шансы нарваться на копирование, если неправильно написаны и перемещающие операции. Перемещающие конструктор и оператор присваивания принимают аргумент rvalue, то есть с &amp;amp;&amp;amp;, но в теле функции оно становится lvalue, так как мы уже дали имя формальному параметру. Короче, для него в теле надо снова вызывать std::move(), если хочется его куда-нибудь переместить или нужет rvalue от него.Как передать и принять аргументыВ объявлении функции f(ClassName a, ClassName const b, ClassName &amp;amp;c, ClassName const&amp;amp; d, ClassName &amp;amp;&amp;amp;e); первые два аргумента принимаются по значению, с вызовами копирующих конструкторов для T, вторые два lvalue ссылки, и последний - rvalue ссылка. С lvalue ссылками всё тут понятно, остаётся только внимательно проследить за временем жизни ссылок, чтобы ненароком кто-то другой (другой поток, обработчик исключения или системного сигнала) не удалил оригинал и у нас не образовалась висячая ссылка.Передача по значению, приём по значениюРассмотрим первый и последний случаи. Приём по значению, вызов возможно дорогих копирующих конструкторов, долго.void foo(ClassName arg){ std::cout &amp;lt;&amp;lt; &quot;foo\\n&quot;; arg.add_two(); std::cout &amp;lt;&amp;lt; arg.get_size() &amp;lt;&amp;lt; &quot;\\n&quot;; return;}...// Вызывающий кодClassName instance(3);foo(instance1);std::cout &amp;lt;&amp;lt; instance1.get_size() &amp;lt;&amp;lt; &quot;\\n&quot;;// Вывод такой// Copy ctor// foo// 5// 3Передача rvalue, приём по значениюvoid foo(ClassName arg){ std::cout &amp;lt;&amp;lt; &quot;foo\\n&quot;; arg.add_two(); std::cout &amp;lt;&amp;lt; arg.get_size() &amp;lt;&amp;lt; &quot;\\n&quot;; return;}...// Вызывающий кодClassName instance(3);foo(std::move(instance1));std::cout &amp;lt;&amp;lt; instance1.get_size() &amp;lt;&amp;lt; &quot;\\n&quot;; // так делать нельзя, это UB// Вывод теперь такой// User defined ctor// Move ctor// foo// 5// 0 - у разных компиляторов может быть по разномуПриняли аргумент по значению, вроде должно произойти копирование, но нет. Передавали-то мы rvalue ссылку, и произошло воровство. Теперь ооригинальный обьект находится в теле вызыванной функции, а в вызывающей… А в вызывающей по разному. Вообще это UB, пользоваться обьектом из которого было выполнено перемещение, и на разных компиляторах может быть разное поведение.Приём rvalueВ случае, когда же у нас в списке параметров стоит ClassName &amp;amp;&amp;amp;arg, мы передаём ссылку. Сам обьект всё ещё остётся принадлежать вызывающему коду. И точно так же как и с lvalue ссылками можно нарваться на повисание этой ссылки. Например в одной функции обьект будет удален, или из него будет выполнено перемещение, как в предыдущем разделе. И всё, привет UB в другой функции.void foo(ClassName &amp;amp;&amp;amp;arg){ std::cout &amp;lt;&amp;lt; &quot;foo\\n&quot;; auto local_arg = std::move(arg); // воруем std::cout &amp;lt;&amp;lt; local_arg.get_size() &amp;lt;&amp;lt; &quot;\\n&quot;; return;}...// Вызывающий кодClassName instance(3);foo(std::move(instance1));std::cout &amp;lt;&amp;lt; instance1.get_size() &amp;lt;&amp;lt; &quot;\\n&quot;; // так делать нельзя, это UBВсё будет норм, если мы просто попользуемся ссылкой или присвоим её локальной переменной без использования std::move – там вызовется копирующий конструктор, и ссылка останется действительной.Что ещёЗдесь в примерах нет никакого выведения типов и, соответственно perfect forwarding’а. Так же предполагается, что запускается всего один поток, с многопоточностью там больше приседаний. Про это потом.Код примеров можно посмотреть тутЕщё можно глянуть вот этот доклад с C++ Russia 2019" }, { "title": "Железнодорожный музей Cité du Train", "url": "/posts/cite-du-train-museum/", "categories": "trains, france, museum", "tags": "", "date": "2022-07-01 22:00:00 +0200", "snippet": "Что делают люди, которые приехали в Эльзас в город Mulhouse? Большая часть ругается и сокрушается, что они проспали свою станцию и не вышли в Страсбурге или Кольмаре. Остальные идут в музей автомобилей Musée National de l’Automobile, но только не мы. Мы идём, конечно же, в железнодорожный музей Cité du Train.Сам музей находится почти на окраине городка. Можно дойти пешком, можно доехать на скоростном трамвае. Музей занимает несколько корпусов и прилегающую территорию. Сейчас они добавили еще экспонатов, но на момент декабря 2021 музей выглядел вот так.Навигация неплоха. И карты подробные, и внутри музея есть маршруты, вдоль которых можно идти туда, где тебе интересно.Вообще французские железные дороги одни из самых передовых и стильных. Я это почерпнул впервые из одной из детких энциклопедий, я это увидел на практике в поездках во Францию и в этом музее, в частности. Франция - одна из стран-производителей рельсовой техники, образец для других заводов и компаний. Современный подвижной состав, конечно, везде превращается в безликие и похожие друг на друга пластиковые обмылки (особенно это заметно на пригородных поездах), но на дорогах всё ещё полно поездов то эпохи, когда все только-только начинали переходить на платформенный подход к дизайну. В Нидерландах тоже можно встретить поезда произведенные французскими компаниями и даже внешне очень похожие на своих французских собратьев по колее. А в музее полно раритетов, которые отражают офигенные модерновые идеи промышленных дизайнеров середины ХХ века.Первый павильон музея посвящен каким-то бессистемным фактам. Там немного про войну, немного про железную дорогу в горах, немного про историю. Есть взорванный партизанами лежащий на боку паровоз. Много пассажирских вагонов разных классов. Чтобы было повеселее, расставлены манекены-персонажи, которые разыгрывают какие-то сценки со звуковым сопровождением. Много мониторов, которые показывают какие-либо исторические съёмки и документальные фильмы, снятые SNCF еще на чёрно-белую пленку. Всё на французскомЯ прям как-то проникся таким раритетным интерьером вагонов и временем, когда были вагон-салоны и вагон-рестораны, где столы сервировались огромным количеством металлических и стеклянных приборов, стены были обиты деревом и тканями. Сразу захотелось в начало ХХ века и быть богатым, чтобы так проехаться. Ибо крестьяне ездили в вагонах 3-4 класса, со своим скотом и товарами сельского хозяйства на ярмарку. А это уже не так интересно.Ладно, далее можно пройти через галерею в большой павильон или выйти на уличную экспозицию. Вторая не сильно богата интересными экспонатами. Сначала там стоит поезд серии Z 5300, печально известный тем, что два таких поезда столкнулись в Париже на Лионском вокзале в 1988г..Затем можно найти небольшой дворик с более современными локомотивами и вагонами. Французы способны, не особо парясь над внешним дизайном, запустить на рельсы четырёхосную коробку с токоприёмниками, и оно будет удачной концепцией и базой для нескольких серий локомотивов.Мне еще понравилось, что рядом с музеем проходит действующая жд линия, и можно в музее посмотреть про то, что только что проехало рядышком.Далее заходим снова внутрь и проходим стенды с масштабными модельками.Посмотрите как мотриса X 4200 напоминает нидерландскую NS 20. Нидерландские жд очень многое взяли из Франции.Далее стоит традиционный для железнодорожных музеев паровоз в разрезе. Но паровозы мне меньше всего интересны потому не останавливаемся на нём. Хотя этот отличается тем, что раз в час он на 5 минут начинает вращать колесами и пыхтеть.А вот что интереснее, так это электровозы. Вот стоит раритет 2D2-5516, тоже в разрезе и даже со схемойА дальше начинается модерн. Даже не так. МОДЕЕЕЕЕРН. Посмотрите, какие они все изящные. Може быть от них художники ретрофутуризма черпали свое вдохновениеСломанные носы (Nez Cassé)SNCF Class CC 40101 аж весь стремится вперёдНу и конечно же никуда без высокоскоростных поездов. Франция - это пионер высокоскоростного движения, наряду с Японией. Японцы запустили свои Синкансены в 1964 году, а французы - TGV (Train à Grande Vitesse) в 1981. Поездам TGV принадлежат мировые рекорды скорости - 515,3 км/ч в 1990 году и 574,8 км/ч в 2007. Но это рекорды, а так, на высокоскоростных линиях они гоняют до 320 км/ч.С нашего посещения музея прошло уже больше полугода, и за это время там еще добавили экспонатов. Да и в целом музей растёт и развивается неплохо, особенно для небольшого провинциального города. Короч, учите французский, если английский и язык страны, где вы живёте уже выучены. Там прикольно.Больше фотографий оттуда будет в моём тематическом инстаче. Так же вот есть инстаграм этого музея" }, { "title": "Железнодорожный музей в Утрехте (Нидерланды)", "url": "/posts/nederlands-spoorwegmuseum/", "categories": "trains, netherlands, museum", "tags": "", "date": "2022-01-21 00:55:17 +0100", "snippet": "В нидерландском Утрехте есть совершенно замечательный музей железных дорог на месте бывшего вокзала (теперь это тупиковая станция, куда раз в час приезжает поезд-челнок).Раньше я бывал в музеях железной дороги в Новосибирске, Санкт-Петербурге и Калининграде. Музей в Утрехте, в отличие от них, направлен на семейный отдых, чем на развлечение для заинтересованных. Это не просто выставка техники с табличками текста из википедии и без всякой базовой инфраструктуры, как в Новосибирске или Калининграде (хотя в Калининграде и вход бесплатный). Это не облагороженное локомотивное депо с той же выставкой техники, парой паровозов в разрезе и доступом в будку на растерзание детям, как в Петербурге. Это большой комплекс активностей для разных возрастов, со множеством ответвлений. Мы с женой (ей тоже было интересно, хотя она не любитель) в июле 2021 проходили там 5 часов, и нам не хватило.Все начинается со старого здания вокзала. В нем касса, администрация, небольшая выставка контрольно-измерительных приборов, две масштабные модели старых пассажирских вагонов и королевская комната ожидания. Там нидерландские монархи ожидали своего поезда в комфортной гостиной.Тут же у старого вокзала стоит электричка, два электровоза и три люксовых пассажирских вагона. В два из них можно зайти и посмотреть на интерьеры.Далее начинается основное здание музей, и только там проверяют билет. Да всё, что выше написано, доступно для посещения бесплатно. А в основном здании - выставка техники (само собой, куда же без этого), разные аттракционы, небольшие подмузеи, библиотека и “лаборатория”.Подмузеи - есть галерея железнодорожного моделизма и игрушек. В том числе Lego-модели нидерландких поездов.Есть подмузей всякой мелочи - маршрутные доски вагонов, железнодорожные старые плакаты, флаги, посуда и даже какой-то унитаз лежит в углу. Не шучуВ “лаборатории” можно на опыте понять, как работают разные механизмы на жд. Почему колеса имеют определенную форму, как происходит электроснабжение локомотивов и почему голуби не дохнут (очень жаль), когда садятся на контактный провод.Несколько раз в день происходят представления. На поворотном кругу дядька рассказывает про этот самый поворотный круг и демонстрирует, как он лёгким движением руки может этим кругом развернуть тепловоз.Далее, есть зал посвященный поезду “Восточный экспресс”. Одна его половина - европейский вокзал с двумя вагонами, другая половина - Константинопольский вокзал. С соответствующими экстерьерами и афишей театральных представлений… Стоп, что? Театр?Ага. В железнодорожном музее есть небольшой театр. И там для детей даются получасовые спектакли с героями-работниками и пассажирами знаменитого поезда. Спектакли на несложном голландском, так что для нас это тоже было полезно и вполне понятно (реально офигенные ощущения, когда начинаешь понимать что-то длиннее пары фраз на третьем языке).Дальше мы идем в еще одно помещение с названием Steel Monsters. Поначалу, невзрачная комната со старой железнодорожной атрибутикой. Но это всего лишь зал ожидания перед американскими горками. Стоп, что? Американские горки?Ага. В железнодорожном музее есть небольшой roller coaster. Без экстрима, но и не колясочка. Ты садишься в четырехместную тележку и в полутьме едешь через паровозное депо, с подьемами и спусками, с проездом под паровозом и световыми инсталляциями, как слесаря ремонтируют котёл. Вот это просто киллер-фича музея. Офигенно. Жаль, что там достаточно темно, чтобы в движении что-то адекватно заснять.Другая большая комната посвящена изобретению паровых машин и появлению первых паровозов. Попадаешь в XIX век в Англию. Прямо в угольную шахту. Выходишь из шахты на типичную улицу типичного английского шахтерского городка. А потом на площадь-станцию. Да, нахрен! Внутри музея запилили экстерьеры улицы и железнодорожной станции с одним из первых паровозов Стефенсона. Так же там есть интерьеры его мастерских с заготовками, чертежами (по комнате бегают механические мыши - мы угорали с них пять минут), и всякие прочие сараи.Еще можно пройти сквозь выставку локомотивов, выйти наружу и дойти до поста механической централизации. Там дядька покажет и расскажет, как работали семафоры, телеграфная связь, и прочая диспетчеризация на железной дороге до внедрения электрических систем.Там еще есть детская площадка, где малыши могут покататься на поездах по кругу и просто побеситься, всякие кафешки-сувенирные магазинчики.И еще мы не успели в одно большое отделение, т.к. музей закрывается в 17:00. Так что лучше приезжать к самому открытию." }, { "title": "C++ ООП на Си", "url": "/posts/oop-implementation-in-c/", "categories": "coding, cpp", "tags": "", "date": "2021-12-13 15:46:00 +0100", "snippet": "ООП в C++ все еще одна из ключевых парадигм. Принято выделять три классические характеристики ООП: инкапсуляция, наследование, полиморфизм. Шутки ради давайте реализуем эти базовые возможности на чистом Си.Классический и заезженный пример - это иерархия shape &amp;lt;- rectangle. на мой взгляд, это слишком искусственно, непрактично и неинтересно. Более полезным может оказаться текстовый логгер. Не претендуя на идеальность реализации и пренебрегая всякими подробностями в виде разных кодировок и локалей, давайте реализуем его.ИнкапсуляцияПод инкапсуляцией следует понимать локальность данных и операций над ними. В сиплюсплюсном классе мы определяем данные и операции для работы с ними, и неявно ипользуем указатель this, который передается “нулевым” параметром в функции-члены класса. На сях давайте определим тупую структуру и три тупые функции, которые будут принимать первым параметром указатель на тупую структуру.typedef struct { char *src_file;} logger_t;void logger_ctor(logger_t *self, char const* src);void logger_dtor(logger_t *self);void log_line(logger_t *self, char const* msg);Отлично! Поместив эти определения в заголовочный файл, и написав какую-нибудь реализацию конструктора, деструктора и функции log_line (например, с выводом в stdout), мы можем подключить это к основному файлу и использовать.int main(int argc, char const *argv[]){ logger_t logger; logger_ctor(&amp;amp;logger, __FILE__); log_line(&amp;amp;logger, &quot;Some message&quot;); log_line(&amp;amp;logger, &quot;One more message&quot;); logger_dtor(&amp;amp;logger); return 0;}НаследованиеПроизводный класс в C++ содержит в себе базовый, конструктор производного сперва вызывает контруктор базового, а деструктор производного вызывает детруктор базового напоследок.Расширим пример с логгером – перенесем логгер в stdout в производный класс и добавим логгер в текстовый файл, а корень иерархии сделаем “абстрактным классом”. Вот так, например, будет выглядеть “класс” логгера в файлtypedef struct { base_logger_t super; FILE* logfile; bool is_file_open;} textfile_logger_t;А его конструктор будет вызывать конструктор базового, передавая ему некоторые из параметровvoid textfile_logger_ctor(textfile_logger_t *self, char const* src) { base_logger_ctor(&amp;amp;self-&amp;gt;super, src); ...}Таким образом получается публичное наследование, и члены базового класса доступны через поле super.ПолиморфизмДинамический полиморфизм и позднее связывание реализуются через vtbl – таблицу указателей на функции, которые мы помечаем виртуальными, и vptr – указатель на эту таблицу. При создании объекта производного класса, его виртуальные функции в процессе исполнения записываются в vtbl, через которую и происходит вся диспетчеризация. Добавим vtbl в базовый класс:struct LoggerVtbl;typedef struct { struct logger_vtbl const * vptr; char *src_file;} base_logger_t;struct logger_vtbl { void (*log) (base_logger_t const * const self, time_t const* timestamp, char const* msg);};...У нас будет одна виртуальная функция void log_that(base_logger_t const * loggers[], uint8_t n_loggers, char const* msg);, которую мы будем использовать вот такint main(int argc, char const *argv[]){ textfile_logger_t text_logger; terminal_logger_t terminal_logger; ... base_logger_t const* loggers[] = { &amp;amp;text_logger.super, &amp;amp;terminal_logger.super }; log_that(loggers, sizeof(loggers)/sizeof(loggers[0]), &quot;Some message&quot;); log_that(loggers, sizeof(loggers)/sizeof(loggers[0]), &quot;One more message&quot;); ...}Во всех конструкторах, и в базовом, и в производных произведем инициализацию vptrvoid base_logger_ctor(base_logger_t *self, char const* src) { static struct logger_vtbl const vtbl = { &amp;amp;log_line_impl }; self-&amp;gt;vptr = &amp;amp;vtbl; ...}И затем добавим каждому классу реализацию log_line_impl с модификатором static. Реализация в базовом классе вызывает assert(0), имитируя ошибку при вызове метода у абстрактного класса, у остальных честно напишем логирование заданного сообщения с таймстампом и именем файла, откуда логирование производится.Как сделать диспетчеризацию вызовов? У нас есть поле базового класса vptr, которому мы привоили при создании разные наборы реализаций виртуальных функций. В базовом класе сделаем вот такую прокси-функциюstatic inline void log_line(base_logger_t const * const logger, time_t const* timestamp, char const* msg) { (*logger-&amp;gt;vptr-&amp;gt;log)(logger, timestamp, msg);}Именно она и вызывает нужные реализации в зависимости от типа объекта.Последний штрих – связать “виртуальную” функцию с прокси-диспетчеромvoid log_that(base_logger_t const * loggers[], uint8_t n_loggers, char const* msg) { time_t timestamp = time(NULL); uint8_t i = 0u; for (i = 0u; i &amp;lt; n_loggers; ++i) { log_line(loggers[i], &amp;amp;timestamp, msg); }}РемаркиРеализация получилась очень наивная. Всё публично, всё явно, руками вызываем все деструкторы, никакого специального синтаксиса. Но главое – базовые идеи локальности данных и операций, иерархии классов и позднего связывания через vtbl реализованы и работают. Полный код можно найти вот тут" }, { "title": "Wuppertal Schwebebahn", "url": "/posts/wuppertal-schwebebahn/", "categories": "trains, germany", "tags": "", "date": "2021-12-06 15:46:00 +0100", "snippet": "Wuppertal Schwebebahn – подвесная железная дорога в городе Вупперталь на западе Германии, недалеко от Дюссельдорфа. Была построена в 1901 году и работает с тех пор, только с перерывом на войну. Каждый из двух вагонов подвешен в двух точках на двухосные моторные тележки. Поезда последнего поколения выглядят офигенно и снаружи и изнутри, создавая ощущение, что будущее уже настало, хотя системе 120 лет. Поезда ходят раз в 10 минут примерно, два маршрута, одна развилка. Мы проехали внутри пару остановок в одну сторону. Внутри - проход по правому борту и два ряда сидений по левому. Вагон едет почти без покачиваний, так что разве что панорамное заднее окно может смущать тех, кто боится высоты." }, { "title": "Третья попытка завести блог", "url": "/posts/third-blog-attempt/", "categories": "Общее", "tags": "", "date": "2021-12-01 00:20:17 +0100", "snippet": "Если глянуть историю коммитов, то там полная дичь. Можно найти несколько полных пересозданий мира. Это я забрасывал эту затею и потом возвращался к ней. Сейчас надоело, что домен простаивает, и решил довести-таки до конца. К тому же, давеча завел канал в ТГ, но там даже маленькие сниппеты кода выглядят богомерзко и нечитаемо.Типичный аджаел - допиливаем на ходу. Я не web-программист, и все эти штуки про js-css-sass знаю понаслышке. Подсматриваю в чужие репозитарии с подобными блогами." } ]

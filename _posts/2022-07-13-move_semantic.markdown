---
layout: post
title:  "Как пользоваться Move semantic на примерах"
date:   2022-07-13 15:46:00 +0100
categories: coding cpp
---
В 2022 году всё ещё существует много компаний, для которых C++11 считается новым стандартом языка. С людьми лучше, множество конференций, статей, книжек, гайдов на ютубе ~~танцев в тиктоке~~ неплохо объяснили идеи и рапространили знания. Для новоприбывших же, возможно, дерево типов ссылок в C++, разные приколы и эффекты могут повергнуть в уныние. Потому, здесь я покажу без особых теоретических запилов как в 80% случаев надо пользоваться семантикой перемещения в версиях языка C++11 и новее. Если вы душный дед из твитора и испытываете желание ~~самоудовлетвориться~~ самоутвердиться, что теория лёгкая, и вы её за две минуты освоили в третьем классе на батином инженерном калькуляторе, то вы ошиблись дверью, хабрахабр дальше по коридору. Остальным велкам.

### Типы конструкторов и подготовка

Здесь нам понадобятся два типа ссылок: обычная ссылка lvalue, которая может стоять слева (и справа) от присваивания (а значит имеет имя), и ссылка rvalue, которая может находиться только справа. Значениями типа rvalue являются результаты вызова функций, литералы.

Начнём, пожалуй с того, что напишем пару килограммов бойлерплейта (нудного, объемного, жизненно необходимого, но весьма скучного кода). Будем использовать для экспериментов вот такой класс:

{% highlight cpp %}
class ClassName
{
public:
    ClassName()
    {
        std::cout << "Default ctor\n";
    }

    ~ClassName()
    {
        std::cout << "Default dtor\n";
    }

    ClassName(int const max_letter_number)
    : v(max_letter_number, "aaa"), s("Vector of triplets")
    {
        std::cout << "User defined ctor\n";
    }

    ClassName(ClassName const& other)
    : v(other.v), s(other.s)
    {
        std::cout <<"Copy ctor\n";
    }

    ClassName& operator=(ClassName const& other)
    {
        std::cout << "Copy assignment\n";
        v = other.v;
        s = other.s;
        return *this;
    }

    ClassName(ClassName &&other)
    : v(std::move(other.v)), s(std::move(other.s))
    {
        std::cout << "Move ctor\n";
    }

    ClassName& operator=(ClassName &&other)
    {
        std::cout << "Move assignment\n";
        v = std::move(other.v);
        s = std::move(other.s);
        return *this;
    }

    std::size_t get_size() const
    {
        return v.size();
    }

    void add_two()
    {
        v.push_back("ddd");
        v.push_back("fff");
        return;
    }

private:
    std::vector<std::string> v;
    std::string s;
};
{% endhighlight %}

Что произошло? Не впадая в мерзкое упрощение с целыми числами, мы завели класс со строчкой и вектором строчек внутри. Для наглядности. Явно реализовали конструктор по умолчанию (без аргументов), пользовательский конструктор (с аргументами) и деструктор. Явно написали копирующие и перемещающие операции. Опять же, чтобы не вспоминать сейчас правило ~~трёх~~ пяти, и что там когда компилятор нам генерирует. Про это потом.

Перемещающие операции отличаются синтаксически лишь двойным амперсандом (так обозначается rvalue ссыль) в списке параметров и отсутствием `const`. И вызовами `std::move()`, которая во время компиляции приводит тип аргумента как раз к нужной нам rvalue. Для встроенных типов в любом случае произойдёт копирование, для них недорогостоящее. Для обьектов, которые не содержат перемещающего конструктора, попытка перемещение так же будет заменена копированием. Так же есть шансы нарваться на копирование, если неправильно написаны и перемещающие операции. Перемещающие конструктор и оператор присваивания принимают аргумент rvalue, то есть с &&, но в теле функции оно становится lvalue, так как мы уже дали имя формальному параметру. Короче, для него в теле надо снова вызывать `std::move()`, если хочется его куда-нибудь переместить или нужет rvalue от него.

### Как передать и принять аргументы

В объявлении функции `f(T a, T const b, T &c, T const& d, T &&e);` первые два аргумента принимаются по значению, с вызовами копирующих конструкторов для T, вторые два lvalue ссылки, и последний - rvalue ссылка. С lvalue ссылками всё тут понятно, остаётся только внимательно проследить за временем жизни ссылок, чтобы ненароком кто-то другой (другой поток, обработчик исключения или системного сигнала) не удалил оригинал и у нас не образовалась висячая ссылка.

#### Передача по значению, приём по значению

Рассмотрим первый и последний случаи. Приём по значению, вызов возможно дорогих копирующих конструкторов, долго.

{% highlight cpp %}
void foo(ClassName arg)
{
    std::cout << "foo\n";
    arg.add_two();
    std::cout << arg.get_size() << "\n";
    return;
}
...
ClassName instance(3);
foo(instance1);
std::cout << instance1.get_size() << "\n";

// Вывод такой
// Copy ctor
// foo
// 5
// 3

{% endhighlight %}

#### Передача rvalue, приём по значению

{% highlight cpp %}
void foo(ClassName arg)
{
    std::cout << "foo\n";
    arg.add_two();
    std::cout << arg.get_size() << "\n";
    return;
}
...
ClassName instance(3);
foo(std::move(instance1));
std::cout << instance1.get_size() << "\n"; // так делать нельзя, это UB

// Вывод теперь такой
// User defined ctor
// Move ctor
// foo
// 5
// 0 - у разных компиляторов может быть по разному

{% endhighlight %}









